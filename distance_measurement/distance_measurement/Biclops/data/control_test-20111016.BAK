#include <stdio.h>
#include "dist_measurement_header.h"
#include "matching.h"


//距離計測用
bool measurement= false;
bool save = false;
double DstToTrgt;	//ターゲットまでの直接距離
double DstHrz;		//ターゲットまでの水平距離
static int save_count=0;
double hosei=0;
double bunbo;
FILE *fp;

//データ取る用
#define IMAGE_COUNTER 100
double dist_average;
double error_data[IMAGE_COUNTER];
double error_average;
double sigma=0;
int image_counter=0;
bool first=false;
double trueDistToTrgt;


//マウスコールバック関数
void on_mouse(int event, int x, int y, int flags, void* param){

	if(!strcmp((const char *)param, "Right")){
		//オンマウスでの枠の表示
		if(event == CV_EVENT_MOUSEMOVE){
			Right->MsX = x;
			Right->MsY = y;
		}
		//左クリックでカメラを回転させる
		else if(event == CV_EVENT_LBUTTONDOWN){
			//どのピクセルに方向転換するかを決め、Turn()に値を入れる
			Right->Turn(x-ImgSzX/2, y-ImgSzY/2);
		}
		//右クリックでテンプレート決定
		else if(event == CV_EVENT_RBUTTONDOWN){
			Right->GtX=max(min(x,ImgSzX-TmpHX),TmpHX);
			Right->GtY=max(min(y,ImgSzY-TmpHX),TmpHX);
			Right->ArX=max(min(x,ImgSzX-VCIHf),(VCIHf+1));
			Right->ArY=max(min(y,ImgSzY-VCIHf),(VCIHf+1));
			Right->MkTmpBL=true;
			Right->TkTmpBL=true;
		}
	}

	if(!strcmp((const char *)param, "Left")){
		//オンマウスでの枠の表示
		if(event == CV_EVENT_MOUSEMOVE){
			Left->MsX = x;
			Left->MsY = y;
		}
		//左クリックでカメラを回転させる
		else if(event == CV_EVENT_LBUTTONDOWN){
			//どのピクセルに方向転換するかを決め、Turn()に値を入れる
			Left->Turn(x-ImgSzX/2, y-ImgSzY/2);
		}
		//右クリックでテンプレート決定
		else if(event == CV_EVENT_RBUTTONDOWN){
			Left->GtX=max(min(x,ImgSzX-TmpHX),TmpHX);
			Left->GtY=max(min(y,ImgSzY-TmpHX),TmpHX);
			Left->ArX=max(min(x,ImgSzX-VCIHf),(VCIHf+1));
			Left->ArY=max(min(y,ImgSzY-VCIHf),(VCIHf+1));
			Left->MkTmpBL=true;
			Left->TkTmpBL=true;
		}
	}

}


//画像ボードクローズ関数-------------------------------------------------------------
void CamBoard_Close(){
	//画像ボードのクローズ
	pxd_PIXCIclose();
}


//------------------------------------------------------------------------------------
//【メイン関数】//////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------------
int main( int argc, char** argv ){

	int key;
	IplImage *tmpImage = cvCreateImage( cvSize( TmpSz*2, TmpSz ), IPL_DEPTH_8U, 1);
	cvSetZero(tmpImage);
	
	//画像ボードと回転台の初期化
	Initialize_camera_board();

	//オブジェクトの作成
	Left = new Matching("Biclops/data/BiclopsDefaultLeft.cfg", 0x1);
	Right = new Matching("Biclops/data/BiclopsDefaultRight.cfg", 0x2);

	//ウィンドウの準備
	char windowNameRight[] = "Right";
	char windowNameLeft[] = "Left";
	cvNamedWindow( windowNameRight, CV_WINDOW_AUTOSIZE );
	cvNamedWindow( windowNameLeft, CV_WINDOW_AUTOSIZE );
	//マウスコールバックの登録
	cvSetMouseCallback( "Right", on_mouse, "Right");
	cvSetMouseCallback( "Left", on_mouse, "Left");

	//テスト
	cvNamedWindow( "TEST", CV_WINDOW_AUTOSIZE );



	if((fp = fopen("measurement.csv", "w")) == NULL ){
		exit(0);
	}
	//fprintf(fp, "save_count, Left[rad], Right[rad], DistToTrgt, 3080, パンカウントLR\n");
	fprintf(fp, "save_count, AVG_error, sigma\n");


	while(1){
		//左右カメラの画像取得
		Left->GetImg();
		Right->GetImg();

		//左右回転台のポジションを取得
		Left->GetPos();
		Right->GetPos();
		
		//テンプレートの作成/////////////////////////////////////////////////
		if(Left->MkTmpBL){
			Left->Mktmpl();		//テンプレート取得メソッド
			cvSetImageROI(tmpImage, cvRect(0, 0, TmpSz, TmpSz) );
			cvCopy(Left->cvImageTMP, tmpImage);
			cvResetImageROI(tmpImage);
		}
		if(Right->MkTmpBL){
			Right->Mktmpl();	//テンプレート取得メソッド
			cvSetImageROI(tmpImage, cvRect(TmpSz, 0, TmpSz, TmpSz) );
			cvCopy(Right->cvImageTMP, tmpImage);
			cvResetImageROI(tmpImage);
		}		
		//テンプレート取得後の処理////////////////////////////////////////////
		if(Right->TkTmpBL && Left->TkTmpBL){
			//テンプレートマッチング
			Right->TmpMtch();
			Left->TmpMtch();

			//画像内でのターゲットの角度計算
			Right->AngClclt();
			Left->AngClclt();

			//水平方向距離計測
			if(measurement){
				printf("Left -> Count[%3d] angle[%.5f deg] angle[%.5f rad] tan[%.5f]\n", Left->pan_pos, Left->pan_pos/33.33+Left->pan_angle*180/M_PI, Left->pan_pos/33.33*M_PI/180+Left->pan_angle, tan(Left->pan_pos/33.33*M_PI/180+Left->pan_angle) );
				printf("Right-> Count[%3d] angle[%.5f deg] angle[%.5f rad] tan[%.5f]\n", Right->pan_pos, Right->pan_pos/33.33+Right->pan_angle*180/M_PI, Right->pan_pos/33.33*M_PI/180+Right->pan_angle, tan(Right->pan_pos/33.33*M_PI/180+Right->pan_angle) );
				
				/*printf("LR[%.5f, %.5f] tan(R)-tan(L)=%.5f ", tan(Left->pan_pos/33.33*M_PI/180+Left->pan_angle-Lhosei), tan(Right->pan_pos/33.33*M_PI/180+Right->pan_angle-Rhosei),
															(tan((Left->pan_pos/33.33-Lhosei)*M_PI/180 + Left->pan_angle) - tan((Right->pan_pos/33.33-Rhosei)*M_PI/180 + Right->pan_angle) ) );
				*/
				bunbo = tan(Left->pan_pos/33.33*M_PI/180 + Left->pan_angle) - tan(Right->pan_pos/33.33*M_PI/180 + Right->pan_angle) + hosei;
				DstToTrgt = LnWdth / bunbo;
				printf("bunbo=%.5f DstToTrgt=%.5f\n",bunbo,  DstToTrgt);
				
				//100フレームの平均を取る処理
				if(image_counter>0){
					if(first){				//最初の位置での100フレーム平均を真値とする
						printf("imagecounter[%d]\n",image_counter);
						image_counter--;	//カウンターのデクリメント
						trueDistToTrgt +=DstToTrgt;
						if(image_counter==0){
							trueDistToTrgt=trueDistToTrgt/IMAGE_COUNTER;
							fprintf(fp, "%.5f\n", trueDistToTrgt);
							printf("真値が取得できました → trueDistToTrgt[%.5f]\n", trueDistToTrgt);
							first = false;
						}
					}
					if(!first && save){
						printf("imagecounter[%d]\n",image_counter);
						image_counter--;	//カウンターのデクリメント
						error_data[image_counter] = fabs(trueDistToTrgt - DstToTrgt);	//誤差の取得
						error_average += error_data[image_counter];
						if(image_counter==0){
							error_average=error_average/IMAGE_COUNTER;	//誤差の平均を求める
							for(int i=IMAGE_COUNTER;i;i--){	//分散を求める
								sigma += (error_average-error_data[i-1])*(error_average-error_data[i-1])/IMAGE_COUNTER;
							}
							printf("取得できました →AVGerror[%.5f], sigma[%.5f]\n", error_average, sigma);
							save_count++;
							printf("%d回目　保存しました\n",save_count);
							fprintf(fp, "%d, %.5f, %.5f\n",save_count, error_average, sigma);

							save = false;
						}
					}
					//
					//if(save)
					//save=false;	save_count++;
					//fprintf(fp, "%d, %.5f, %.5f, %.3f, ,%3d, %3d \n", save_count, Left->pan_pos/33.33*M_PI/180+Left->pan_angle, Right->pan_pos/33.33*M_PI/180+Right->pan_angle, DstToTrgt, Left->pan_pos, Right->pan_pos);
					//printf("%d回目　保存しました\n",save_count);
				}
			}

			//カメラの回転
			if(Right->MtchPrm[8]<728)	//相違度が一定以下なら，回転を行う．17F/S　←相違度が大きいと回転しない(テンプレートを見失ったら回転しない)
			{
				Right->CmrTrn( Right->pan_angle, Right->tilt_angle);
			}
			else printf("右カメラ、ターゲット見失ってます\n");
			if(Left->MtchPrm[8]<728)	//相違度が一定以下なら，回転を行う．17F/S　←相違度が大きいと回転しない(テンプレートを見失ったら回転しない)
			{
				Left->CmrTrn( Left->pan_angle, Left->tilt_angle);
			}
			else printf("左カメラ、ターゲット見失ってます\n");

		}
		
		//////////////////////////////////////////////////////////////////////

		//【表示関係】////////////////////////////////////////////////////////
		//画像の中心を表示
		cvLine(Right->cvImageRGB, cvPoint(ImgSzX, ImgSzY/2),cvPoint(0, ImgSzY/2), CV_RGB(255,255,255), 1,8, 0);
		cvLine(Right->cvImageRGB, cvPoint(ImgSzX/2, ImgSzY),cvPoint(ImgSzX/2, 0), CV_RGB(255,255,255), 1,8, 0);
		cvLine(Left->cvImageRGB, cvPoint(ImgSzX, ImgSzY/2),cvPoint(0, ImgSzY/2), CV_RGB(255,255,255), 1,8, 0);
		cvLine(Left->cvImageRGB, cvPoint(ImgSzX/2, ImgSzY),cvPoint(ImgSzX/2, 0), CV_RGB(255,255,255), 1,8, 0);

		//画像中心に小さい十字マーク
		//cvLine(Right->cvImageRGB, cvPoint(ImgSzX/2-5, ImgSzY/2),cvPoint(ImgSzX/2+5, ImgSzY/2), CV_RGB(255,255,255), 1,8, 0);
		//cvLine(Right->cvImageRGB, cvPoint(ImgSzX/2, ImgSzY/2-5),cvPoint(ImgSzX/2, ImgSzY/2+5), CV_RGB(255,255,255), 1,8, 0);
		//cvLine(Left->cvImageRGB, cvPoint(ImgSzX/2-5, ImgSzY/2),cvPoint(ImgSzX/2+5, ImgSzY/2), CV_RGB(255,255,255), 1,8, 0);
		//cvLine(Left->cvImageRGB, cvPoint(ImgSzX/2, ImgSzY/2-5),cvPoint(ImgSzX/2, ImgSzY/2+5), CV_RGB(255,255,255), 1,8, 0);

		//オンマウスでテンプレート位置を表示
		cvDrawRect( Right->cvImageRGB, cvPoint(Right->MsX-TmpHX, Right->MsY-TmpHX), cvPoint(Right->MsX+TmpHX, Right->MsY+TmpHX), CV_RGB(255,0,0), 1, 8, 0);
		cvLine(Right->cvImageRGB, cvPoint(Right->MsX-TmpHX, Right->MsY), cvPoint(Right->MsX+TmpHX, Right->MsY), CV_RGB(255,0,0), 1,8, 0);
		cvLine(Right->cvImageRGB, cvPoint(Right->MsX, Right->MsY-TmpHX), cvPoint(Right->MsX, Right->MsY+TmpHX), CV_RGB(255,0,0), 1,8, 0);

		cvDrawRect( Left->cvImageRGB, cvPoint(Left->MsX-TmpHX, Left->MsY-TmpHX), cvPoint(Left->MsX+TmpHX, Left->MsY+TmpHX), CV_RGB(255,0,0), 1, 8, 0);
		cvLine(Left->cvImageRGB, cvPoint(Left->MsX-TmpHX, Left->MsY), cvPoint(Left->MsX+TmpHX, Left->MsY), CV_RGB(255,0,0), 1,8, 0);
		cvLine(Left->cvImageRGB, cvPoint(Left->MsX, Left->MsY-TmpHX), cvPoint(Left->MsX, Left->MsY+TmpHX), CV_RGB(255,0,0), 1,8, 0);
	
		if(Right->TkTmpBL){		//【右】検出領域を表示
			cvDrawRect( Right->cvImageRGB, cvPoint(Right->MtchPrm[6]-VCIHf, Right->MtchPrm[7]-VCIHf), cvPoint(Right->MtchPrm[6]+VCIHf, Right->MtchPrm[7]+VCIHf), CV_RGB(255,0,0), 1, 8, 0);
			//テンプレートマッチング検出結果
			cvLine(Right->cvImageRGB, cvPoint(Right->MtchPrm[2]-5, Right->MtchPrm[3]),cvPoint(Right->MtchPrm[2]+5, Right->MtchPrm[3]), CV_RGB(255,255,0), 1,8, 0);
			cvLine(Right->cvImageRGB, cvPoint(Right->MtchPrm[2], Right->MtchPrm[3]-5),cvPoint(Right->MtchPrm[2], Right->MtchPrm[3]+5), CV_RGB(255,255,0), 1,8, 0);
		
			cvDrawRect( Right->cvImageRGB, cvPoint(Right->MtchPrm[2]-TmpHX, Right->MtchPrm[3]-TmpHX), cvPoint(Right->MtchPrm[2]+TmpHX, Right->MtchPrm[3]+TmpHX), CV_RGB(255,255,0), 1, 8, 0);
		}

		if(Left->TkTmpBL){		//【左】検出領域を表示
			cvDrawRect( Left->cvImageRGB, cvPoint(Left->MtchPrm[6]-VCIHf, Left->MtchPrm[7]-VCIHf), cvPoint(Left->MtchPrm[6]+VCIHf, Left->MtchPrm[7]+VCIHf), CV_RGB(255,0,0), 1, 8, 0);
			//テンプレートマッチング検出結果
			cvLine(Left->cvImageRGB, cvPoint(Left->MtchPrm[2]-5, Left->MtchPrm[3]),cvPoint(Left->MtchPrm[2]+5, Left->MtchPrm[3]), CV_RGB(255,255,0), 1,8, 0);
			cvLine(Left->cvImageRGB, cvPoint(Left->MtchPrm[2], Left->MtchPrm[3]-5),cvPoint(Left->MtchPrm[2], Left->MtchPrm[3]+5), CV_RGB(255,255,0), 1,8, 0);
		
			cvDrawRect( Left->cvImageRGB, cvPoint(Left->MtchPrm[2]-TmpHX, Left->MtchPrm[3]-TmpHX), cvPoint(Left->MtchPrm[2]+TmpHX, Left->MtchPrm[3]+TmpHX), CV_RGB(255,255,0), 1, 8, 0);
		}


		//【画像表示】
		cvShowImage( windowNameRight, Right->cvImageRGB );
		cvShowImage( windowNameLeft, Left->cvImageRGB );

		cvShowImage( "TEST", tmpImage);


		key = cvWaitKey(30);
		if(key == 'q')break;
		else if(key==' '){
			if(!measurement)measurement = true;
			else measurement = false;
		}
		else if(key =='s'){
			image_counter = IMAGE_COUNTER;
			error_average = 0;
			sigma = 0;
			save = true;
		}
		else if(key =='f'){
			image_counter = IMAGE_COUNTER;
			first = true;
		}
		else if(key =='a'){
			printf("補正値を入力します\n 補正定数=%.5f\n",0.05-bunbo);
			hosei = 0.05-bunbo;
		}
		else if(key =='h'){
			Right->TurnToHome();
			Left->TurnToHome();
		}

	}

	CamBoard_Close();
	//画像メモリの開放
	Right->Close();
	//Left->Close();
	fclose(fp);
	return 0;	


}